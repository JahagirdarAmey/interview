1. What is serialization 
- process of converting objects into byte stream 
- byte stream can be transformed over internet, saved into file, db
- after transforming, deserialized into original state 

2. WAP to serialize & deserialize object & persist it in file 
-  
OutputStream fout = new FileOutputStream("ser.txt");
ObjectOutput oout = new ObjectOutputStream(fout);
System.out.println("Serialization process has started, serializing employee objects...");
oout.writeObject(object1);

InputStream fin=new FileInputStream("ser.txt");
ObjectInput oin=new ObjectInputStream(fin);
System.out.println("DeSerialization process has started, displaying employee objects...");
Employee emp;
emp=(Employee)oin.readObject();

3. Difference between Externalizable and Serialization interface (Important)?

Serializable 
	- Marker interface
	- Own default serialization process 
	- Serialization can be customized by defining readObject() writeObject. (NOTE: Not by overriding)

Externalizable 
	- Not a marker interface
	- we need to override writeExternal() and readExternal() for serialization process to happen. 
	-  Serialization process is completely customized. We need to override Externalizable interface’s writeExternal() and readExternal() methods.
	
4.  How can you customize Serialization and DeSerialization process when you have implemented Serializable interface (Important)?
- We can customize Serialization process by defining writeObject()  method & DeSerialization process by defining readObject() method.
- Let’s customize Serialization
  private void writeObject(ObjectOutputStream os) {
           System.out.println("In, writeObject() method.");    
           try {
                  os.writeInt(this.id);
                  os.writeObject(this.name);
           } catch (Exception e) {
                  e.printStackTrace();
           }
    } 
- Let’s customize DeSerialization process
 private void readObject(ObjectInputStream ois) {
           System.out.println("In, readObject() method.");
           try {
                  id=ois.readInt();
                  name=(String)ois.readObject();
           } catch (Exception e) {
                  e.printStackTrace();
           }
    } 

5. Wap to explain how can we Serialize and DeSerialize object by implementing Externalizable interface (Important)?
- override writeExternal() and readExternal() 
-
    public void writeExternal(ObjectOutput oo) throws IOException {
           System.out.println("in writeExternal()");
           oo.writeInt(id);
           oo.writeObject(name);
   }
-
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
           System.out.println("in readExternal()");
           this.id=in.readInt();
           this.name=(String)in.readObject();
   }

6. How can you avoid certain member variables of class from getting Serialized?
- Mark them as static or transient 

7. What is serialVersionUID?
- serialVersionUID is used for version control of object.
- The serialization at runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. 
- JVM assigns serialVersionUID to every serializable instace. 
- If we  don’t define serialVersionUID in the class, and any modification is made in class, then we won’t be able to deSerialize our class because serialVersionUID generated by java compiler for modified class will be different from old serialized object.  And deserialization process will end up throwing java.io.InvalidClassException  (because of serialVersionUID mismatch) 

8. What are compatible and incompatible changes in Serialization process?
- Compatible changes are those changes which does not affect deSerialization process even if class was updated after being serialized (provided serialVersionUID has been declared)
- Adding new fields.
- Adding writeObject()/readObject()  methods
- Changing access modifier of a field
- Changing a field from static to non static OR changing transient filed to non transient field

- InCompatible changes are those changes which affect deSerialization process if class was updated after being serialized (provided serialVersionUID has been declared)
- Deletion of fields.
- Changing a nonstatic field to static or  non transient field to transient field.
-  Modifying the writeObject() / readObject() method

9. What if Serialization is not available, is any any other alternative way to transfer object over network?
- We can can convert JSON to transfer the object. JSON is helpful in stringifying and de stringifying object.
- Hibernate (ORM tool) helps in persisting object as it in database and later we can read persisted object.

10. Why static member variables are not part of java serialization process (Important)?
-  Serialization is applicable on objects or primitive data types only, but static members are class level variables, therefore, different object’s of same class have same value for static member. 
- So, serializing static member will consume unnecessary space and time.
- Also, if modification is made in static member by any of the object, it won’t be in sync with other serialized object’s value.

11.  What will happen if one the member of class does not implement Serializable interface (Important)?
- If any of the member does not implement Serializable than  NotSerializableException is thrown.
- Example 
 class Employee implements Serializable {
    
    private static final long serialVersionUID = 1L;
    private Integer id;
    private MyClass myClass ; // Not implementing serializable 
}

12.  What will happen if we have used List, Set and Map as member of class?
-  Java Api’s. ArrayList, HashSet and HashMap implements Serializable interface

13.  Is constructor of class called during DeSerialization process?
If Serializable has been implemented - constructor is not called during DeSerialization process.
But, if Externalizable has been implemented - constructor is called during DeSerialization process.

14. Is constructor of super class called during DeSerialization process of subclass (Important)?
If superclass has implemented Serializable - constructor is not called during DeSerialization process.
If superclass has not implemented Serializable - constructor is called during DeSerialization process.

15. Are primitive types part of serialization process? 
- YES

16. What values will int and Integer will be initialized to during DeSerialization process if they were not part of Serialization?
-  int will be initialized to 0 and Integer will be initialized to null during DeSerialization (if they were not part of Serialization process).

17. How you can avoid Deserialization process creating another instance of Singleton class (Important)?
- We can simply use readResove() method to return same instance of class, rather than creating a new one.
- Defining readResolve() method ensures that we don't break singleton pattern during DeSerialization process.
- Also define readObject() method, rather than creating new instance, assign current object to INSTANCE like done below :
private void readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException{
        ois.defaultReadObject();
        synchronized (SingletonClass.class) {
         if (INSTANCE == null) {
               INSTANCE = this;
         }
        }
  }

18. Purpose of serializing Singleton class OR  purpose of saving singleton state?
-  Let’s take example of our laptop, daily eod we need to shut it down, but rather than shutting it down hibernate (save state of  laptop) is better option because it enables us to resume at same point where we leaved it, like wise serializing singleton OR saving state of Singleton can be very handy.

19.  How can subclass avoid Serialization if its superClass has implemented Serialization interface (Important)?
-  If superClass has implemented Serializable that means subclass is also Serializable (as subclass always inherits all features from its parent class), for avoiding Serialization in sub-class we can define writeObject() method and throw NotSerializableException() from there as done below.

20. Externalizable extends serializable ?
- YES

21. Final in serialization 


